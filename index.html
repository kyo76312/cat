<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Hero Survival Shooter</title>
  <style>
    :root{
      --bg:#0b0f16;
      --panel:rgba(0,0,0,.45);
      --txt:#eaf2ff;
      --joy:128px;
    }
    *{box-sizing:border-box}
    html,body{
      margin:0;width:100%;height:100%;
      overflow:hidden;touch-action:none;
      background:var(--bg);color:var(--txt);
      font-family:monospace;user-select:none;-webkit-user-select:none;
    }
    canvas{
      display:block;width:100vw;height:100vh;
      image-rendering:pixelated;image-rendering:crisp-edges;
      background:linear-gradient(#0b0f16,#111a2a);
    }
    #hud{
      position:fixed;left:10px;top:10px;z-index:10;
      background:var(--panel);padding:8px 10px;border-radius:8px;font-size:14px;line-height:1.4;
    }
    #controls{position:fixed;inset:0;pointer-events:none;z-index:20}
    #joy{
      position:absolute;left:14px;bottom:14px;width:var(--joy);height:var(--joy);border-radius:50%;
      background:rgba(255,255,255,.07);border:2px solid rgba(255,255,255,.2);
      pointer-events:auto;touch-action:none;
    }
    #knob{
      position:absolute;left:calc(50% - 25px);top:calc(50% - 25px);
      width:50px;height:50px;border-radius:50%;
      background:rgba(255,255,255,.24);border:2px solid rgba(255,255,255,.35);
      transform:translate(0,0);
    }
    #over{
      position:fixed;inset:0;display:none;z-index:30;align-items:center;justify-content:center;
      background:rgba(0,0,0,.62);touch-action:none;
    }
    #card{
      width:min(320px,86vw);background:#171d2b;border:2px solid #2a3348;border-radius:12px;
      padding:20px;text-align:center;
    }
    #card h1{margin:0 0 12px;color:#ff7d7d}
    #restart{
      width:100%;padding:12px;border:0;border-radius:8px;background:#2fbf72;color:#fff;
      font-size:18px;font-weight:700;touch-action:none;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="hud">
    <div id="hp">HP: 100</div>
    <div id="score">Score: 0</div>
    <div id="time">Time: 0.0s</div>
    <div id="bulletLv">Bullet Lines: 1</div>
  </div>

  <div id="controls">
    <div id="joy"><div id="knob"></div></div>
  </div>

  <div id="over">
    <div id="card">
      <h1>GAME OVER</h1>
      <div id="result" style="margin-bottom:12px"></div>
      <button id="restart">重新開始</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = false;

    const hpEl = document.getElementById("hp");
    const scoreEl = document.getElementById("score");
    const timeEl = document.getElementById("time");
    const bulletLvEl = document.getElementById("bulletLv");
    const overEl = document.getElementById("over");
    const resultEl = document.getElementById("result");
    const restartBtn = document.getElementById("restart");
    const joyEl = document.getElementById("joy");
    const knobEl = document.getElementById("knob");

    const heroImg = new Image();
    const slimeImg = new Image();
    const bulletImg = new Image();
    heroImg.src = "assets/hero.png";
    slimeImg.src = "assets/slime.png";
    bulletImg.src = "assets/bullet.png";

    const state = {
      player: null,
      bullets: [],
      enemies: [],
      powerups: [],
      score: 0,
      t: 0,
      spawnTimer: 0,
      bossTimer: 10,
      bossCount: 0,
      over: false
    };

    const input = { x: 0, y: 0 };
    let joyId = null;
    let joyCenter = { x: 0, y: 0 };
    let joyR = 40;
    let last = 0;

    function resize() {
      canvas.width = innerWidth;
      canvas.height = innerHeight;
      refreshJoy();
    }
    addEventListener("resize", resize);
    resize();

    document.addEventListener("touchstart", e => e.preventDefault(), { passive: false });
    document.addEventListener("touchmove", e => e.preventDefault(), { passive: false });

    class Player {
      constructor() {
        this.x = canvas.width * 0.5;
        this.y = canvas.height * 0.78;
        this.r = 12;
        this.hp = 100;
        this.speed = 255;
        this.fireCd = 0;
        this.fireInterval = 0.1; // 自動連發
        this.bulletLines = 1;
      }

      update(dt) {
        const nx = this.x + input.x * this.speed * dt;
        const ny = this.y + input.y * this.speed * dt;
        this.x = Math.max(this.r, Math.min(canvas.width - this.r, nx));
        this.y = Math.max(this.r, Math.min(canvas.height - this.r, ny));

        if (this.fireCd > 0) this.fireCd -= dt;
        if (this.fireCd <= 0 && !state.over) {
          this.fireCd = this.fireInterval;
          this.shoot();
        }
      }

      shoot() {
        const count = this.bulletLines;
        const gap = 14;
        const center = (count - 1) / 2;
        for (let i = 0; i < count; i++) {
          const offset = (i - center) * gap;
          state.bullets.push({
            x: this.x + offset,
            y: this.y - 14,
            vx: 0,
            vy: -620,
            r: 5,
            dmg: 1
          });
        }
      }

      draw() {
        const s = 28;
        if (heroImg.complete && heroImg.naturalWidth) {
          ctx.drawImage(heroImg, this.x - s / 2, this.y - s / 2, s, s);
        } else {
          ctx.fillStyle = "#6ed3ff";
          ctx.fillRect(this.x - 10, this.y - 10, 20, 20);
        }
      }
    }

    class Enemy {
      constructor(isBoss, diff) {
        this.isBoss = isBoss;
        this.x = Math.random() * (canvas.width - 30) + 15;
        this.y = -30 - Math.random() * 90;

        if (isBoss) {
          state.bossCount += 1;
          const k = state.bossCount;
          const scale = 1 + k * 0.2; // 每次更大
          this.r = 18 * scale;
          this.hp = Math.floor(20 + k * 16 + diff * 40);
          this.speed = 120 + k * 6 + diff * 80;
          this.reward = true;
        } else {
          this.r = 12;
          this.hp = 1 + Math.floor(diff * 3.5 + state.t / 30); // 小怪 HP 成長
          this.speed = 90 + diff * 120 + Math.random() * 70;
          this.reward = false;
        }
      }

      update(dt) {
        const dx = state.player.x - this.x;
        const homing = Math.max(-1, Math.min(1, dx / 140));
        this.x += homing * (85 + state.t * 0.35 + (this.isBoss ? 50 : 0)) * dt;
        this.y += this.speed * dt;
      }

      draw() {
        const size = this.r * 2.15;
        if (slimeImg.complete && slimeImg.naturalWidth) {
          ctx.drawImage(slimeImg, this.x - size / 2, this.y - size / 2, size, size);
        } else {
          ctx.fillStyle = this.isBoss ? "#ff8f8f" : "#82ff9a";
          ctx.fillRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
        }

        // 血條
        const maxHp = this.isBoss ? Math.max(20, this.hp) : Math.max(2, this.hp);
        const w = this.isBoss ? 52 : 24;
        const ratio = Math.max(0, Math.min(1, this.hp / maxHp));
        ctx.fillStyle = "#000";
        ctx.fillRect(this.x - w / 2, this.y - this.r - 10, w, 4);
        ctx.fillStyle = this.isBoss ? "#ff5252" : "#88ff88";
        ctx.fillRect(this.x - w / 2, this.y - this.r - 10, w * ratio, 4);
      }
    }

    function spawnEnemy(dt) {
      state.spawnTimer -= dt;
      state.bossTimer -= dt;

      const diff = Math.min(1.5, state.t / 75); // 75 秒後已很硬
      const interval = Math.max(0.07, 0.55 - diff * 0.35); // 怪大量增加
      const batch = 2 + Math.floor(state.t / 14); // 每波數量越來越大

      if (state.spawnTimer <= 0) {
        state.spawnTimer = interval;
        for (let i = 0; i < batch; i++) state.enemies.push(new Enemy(false, diff));
      }

      if (state.bossTimer <= 0) {
        state.bossTimer = 10;
        state.enemies.push(new Enemy(true, diff));
      }
    }

    function hitCircle(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const rr = a.r + b.r;
      return dx * dx + dy * dy <= rr * rr;
    }

    function spawnPowerup(x, y) {
      state.powerups.push({
        x, y, r: 18, ttl: 12, text: "POWERUP"
      });
    }

    function update(dt) {
      if (state.over) return;
      state.t += dt;
      state.player.update(dt);
      spawnEnemy(dt);

      for (const b of state.bullets) {
        b.x += b.vx * dt;
        b.y += b.vy * dt;
      }
      state.bullets = state.bullets.filter(b => b.y > -40);

      for (const e of state.enemies) {
        e.update(dt);
        if (e.y > canvas.height + e.r + 20) {
          state.player.hp -= e.isBoss ? 14 : 3; // 漏怪懲罰
          e.hp = 0;
        }
      }

      // 子彈打敵人
      for (const b of state.bullets) {
        for (const e of state.enemies) {
          if (e.hp > 0 && hitCircle(b, e)) {
            e.hp -= b.dmg;
            b.y = -999;
            if (e.hp <= 0) {
              state.score += e.isBoss ? 20 : 1;
              if (e.reward) spawnPowerup(e.x, e.y);
            }
            break;
          }
        }
      }

      // 敵人碰撞玩家
      for (const e of state.enemies) {
        if (e.hp > 0 && hitCircle(e, state.player)) {
          state.player.hp -= e.isBoss ? 20 : 8;
          e.hp = 0;
          if (e.reward) spawnPowerup(e.x, e.y);
        }
      }

      // 更新 POWERUP
      for (const p of state.powerups) {
        p.y += 16 * dt;
        p.ttl -= dt;
        if (hitCircle(p, state.player)) {
          state.player.bulletLines += 2; // 每次+2排
          p.ttl = -1;
        }
      }
      state.powerups = state.powerups.filter(p => p.ttl > 0);

      state.enemies = state.enemies.filter(e => e.hp > 0);

      if (state.player.hp <= 0) {
        state.player.hp = 0;
        gameOver();
      }
    }

    function drawBackground() {
      ctx.fillStyle = "#0c1220";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "rgba(255,255,255,.18)";
      for (let i = 0; i < 65; i++) {
        const y = (i * 31 + (state.t * 160) % canvas.height) % canvas.height;
        const x = (i * 71) % canvas.width;
        ctx.fillRect(x, y, 2, 2);
      }
    }

    function draw() {
      drawBackground();

      // bullets
      for (const b of state.bullets) {
        const s = 12;
        if (bulletImg.complete && bulletImg.naturalWidth) {
          ctx.drawImage(bulletImg, b.x - s / 2, b.y - s / 2, s, s);
        } else {
          ctx.fillStyle = "#ffe57d";
          ctx.fillRect(b.x - 2, b.y - 6, 4, 12);
        }
      }

      // enemies
      for (const e of state.enemies) e.draw();
      state.player.draw();

      // powerup text
      for (const p of state.powerups) {
        ctx.fillStyle = "#ffd94a";
        ctx.font = "bold 16px monospace";
        ctx.textAlign = "center";
        ctx.fillText(p.text, p.x, p.y);
      }

      hpEl.textContent = "HP: " + Math.ceil(state.player.hp);
      scoreEl.textContent = "Score: " + state.score;
      timeEl.textContent = "Time: " + state.t.toFixed(1) + "s";
      bulletLvEl.textContent = "Bullet Lines: " + state.player.bulletLines;
    }

    function gameOver() {
      state.over = true;
      overEl.style.display = "flex";
      resultEl.textContent = `生存 ${state.t.toFixed(1)} 秒 / 擊殺 ${state.score} 隻`;
    }

    function reset() {
      state.player = new Player();
      state.bullets = [];
      state.enemies = [];
      state.powerups = [];
      state.score = 0;
      state.t = 0;
      state.spawnTimer = 0;
      state.bossTimer = 10;
      state.bossCount = 0;
      state.over = false;

      input.x = 0;
      input.y = 0;
      knobEl.style.transform = "translate(0,0)";
      overEl.style.display = "none";
    }

    function loop(ts) {
      const dt = Math.min(0.033, (ts - last) / 1000 || 0.016);
      last = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function refreshJoy() {
      const r = joyEl.getBoundingClientRect();
      joyCenter.x = r.left + r.width / 2;
      joyCenter.y = r.top + r.height / 2;
      joyR = r.width * 0.36;
    }

    function joyMove(t) {
      const dx = t.clientX - joyCenter.x;
      const dy = t.clientY - joyCenter.y;
      const len = Math.hypot(dx, dy) || 1;
      const c = Math.min(len, joyR);
      const nx = dx / len;
      const ny = dy / len;
      input.x = nx * (c / joyR);
      input.y = ny * (c / joyR);
      knobEl.style.transform = `translate(${nx * c}px, ${ny * c}px)`;
    }

    joyEl.addEventListener("touchstart", e => {
      if (joyId !== null || state.over) return;
      joyId = e.changedTouches[0].identifier;
      joyMove(e.changedTouches[0]);
    }, { passive: false });

    joyEl.addEventListener("touchmove", e => {
      if (joyId === null) return;
      for (const t of e.changedTouches) if (t.identifier === joyId) joyMove(t);
    }, { passive: false });

    function joyEnd(e) {
      if (joyId === null) return;
      for (const t of e.changedTouches) {
        if (t.identifier === joyId) {
          joyId = null;
          input.x = 0;
          input.y = 0;
          knobEl.style.transform = "translate(0,0)";
          break;
        }
      }
    }
    joyEl.addEventListener("touchend", joyEnd, { passive: false });
    joyEl.addEventListener("touchcancel", joyEnd, { passive: false });

    restartBtn.addEventListener("touchstart", reset, { passive: false });
    restartBtn.addEventListener("click", reset);

    reset();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
