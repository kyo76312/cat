<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>貓貓生存</title>
  <style>
    :root { --panel: rgba(0,0,0,.45); --joy: 128px; }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
      background: #0a1018;
      color: #eaf2ff;
      font-family: monospace;
      user-select: none;
      -webkit-user-select: none;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #hud {
      position: fixed;
      left: 10px;
      top: 10px;
      z-index: 10;
      background: var(--panel);
      border-radius: 8px;
      padding: 8px 10px;
      min-width: 250px;
      font-size: 13px;
      line-height: 1.35;
    }
    #controls {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 20;
    }
    .joy {
      position: absolute;
      width: var(--joy);
      height: var(--joy);
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,.24);
      background: rgba(255,255,255,.08);
      pointer-events: auto;
      touch-action: none;
    }
    #joyMove { left: 14px; bottom: 14px; }
    #joyAim { right: 14px; bottom: 14px; }
    .stick {
      position: absolute;
      left: calc(50% - 25px);
      top: calc(50% - 25px);
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,.36);
      background: rgba(255,255,255,.24);
      transform: translate(0,0);
    }
    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      background: rgba(0,0,0,.62);
      touch-action: none;
    }
    .panel {
      width: min(430px, 92vw);
      background: #18243b;
      border: 2px solid #304667;
      border-radius: 12px;
      padding: 14px;
      text-align: center;
    }
    .panel h2 { margin: 0 0 10px; font-size: 24px; }
    .desc { margin: 0 0 10px; font-size: 13px; opacity: .92; }
    .dialogText { white-space: pre-line; text-align: left; line-height: 1.5; }
    #result { white-space: pre-line; }
    .btn {
      width: 100%;
      padding: 10px;
      margin-top: 8px;
      border: 1px solid #4a638e;
      border-radius: 8px;
      background: #2a3f61;
      color: #fff;
      font-size: 14px;
      text-align: left;
      touch-action: none;
    }
    .btn.main {
      border: 0;
      text-align: center;
      background: #30ad73;
      font-weight: bold;
      font-size: 16px;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div id="hudVersion">版本號：02261020</div>
  <div id="hudHp">生命：200</div>
  <div id="hudTime">時間：0.0s</div>
  <div id="hudCombo">連殺：0</div>
  <div id="hudSpr">散射：Lv0</div>
  <div id="hudBnc">彈射：Lv0</div>
  <div id="hudDmg">重擊：Lv0</div>
</div>

<div id="controls">
  <div id="joyMove" class="joy"><div id="stickMove" class="stick"></div></div>
  <div id="joyAim" class="joy"><div id="stickAim" class="stick"></div></div>
</div>

<div id="elementModal" class="overlay">
  <div class="panel">
    <h2>選擇屬性彈</h2>
    <p class="desc">首次吃到 POWERUP 時選擇</p>
    <button class="btn" id="pickFire">火彈：命中爆炸</button>
    <button class="btn" id="pickIce">冰彈：命中緩速（Lv1:20%，每級+10%）</button>
    <button class="btn" id="pickThunder">雷彈：命中連鎖閃電</button>
  </div>
</div>

<div id="upgradeModal" class="overlay">
  <div class="panel">
    <h2>選擇升級</h2>
    <p class="desc" id="upDesc"></p>
    <button class="btn" id="upElement"></button>
    <button class="btn" id="upSpread"></button>
    <button class="btn" id="upBounce"></button>
    <button class="btn" id="upDamage"></button>
    <button class="btn" id="upHeal"></button>
    <p class="desc" id="upQueue"></p>
  </div>
</div>

<div id="gameOverModal" class="overlay">
  <div class="panel">
    <h2 id="gameOverTitle" style="color:#ff8f8f">GAME OVER</h2>
    <p class="desc" id="result"></p>
    <button id="restartBtn" class="btn main">重新開始</button>
  </div>
</div>

<div id="finalBossModal" class="overlay">
  <div class="panel">
    <h2 style="color:#ffb6da">最終BOSS</h2>
    <p class="desc dialogText" id="finalBossText">你好啊，沒想到你可以堅持到現在呢！
不過就到這裡為止了。
接下來就由我可愛粉紅雲來做你的對手！</p>
    <button id="finalBossConfirm" class="btn main">確認</button>
  </div>
</div>

<script>
const AFFIX = {
  TANK: "tank",
  FAST: "fast",
  CURSE: "curse",
  FIRE: "fire",
  ICE: "ice",
  LIGHTNING: "lightning",
  DASH: "dash",
  MULTI: "multi",
  TELEPORT: "teleport",
  SPLIT: "split"
};

const AFFIX_ZH = {
  tank: "特別強壯",
  fast: "特別快速",
  curse: "衰老詛咒",
  fire: "火焰強化",
  ice: "冰凍強化",
  lightning: "閃電強化",
  multi: "多重射擊",
  teleport: "傳送",
  split: "分裂"
};

AFFIX_ZH[AFFIX.DASH] = "衝刺";

const MOB_ORDER = [
  "World01_001_GreenGoo",
  "World01_003_Bird",
  "World01_004_WailingPrince",
  "World01_005_Shello",
  "World01_006_Witch",
  "World01_007_Pirate",
  "World01_002_Salamander",
  "World04_002_ ScoutMachine",
  "World04_003_ Outlaw",
  "World04_001_ LaserDrone"
];

const MOB_STATS = {
  "World01_001_GreenGoo": { hp: 2, speed: 70, size: 11, dmg: 5 },
  "World01_003_Bird": { hp: 3, speed: 78, size: 11, dmg: 5.5 },
  "World01_004_WailingPrince": { hp: 4, speed: 85, size: 11.5, dmg: 6 },
  "World01_005_Shello": { hp: 5, speed: 92, size: 12, dmg: 6.2 },
  "World01_006_Witch": { hp: 6, speed: 98, size: 12.5, dmg: 6.5 },
  "World01_007_Pirate": { hp: 7, speed: 104, size: 13, dmg: 7 },
  "World01_002_Salamander": { hp: 9, speed: 110, size: 13.5, dmg: 7.5 },
  "World04_002_ ScoutMachine": { hp: 11, speed: 116, size: 14, dmg: 8 },
  "World04_003_ Outlaw": { hp: 13, speed: 122, size: 14.5, dmg: 8.5 },
  "World04_001_ LaserDrone": { hp: 16, speed: 128, size: 15, dmg: 9 }
};

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

const heroImg = new Image();
heroImg.src = "assets/hero.png";
const bulletImg = new Image();
bulletImg.src = "assets/bullet.png";
const finalBossImg = new Image();
finalBossImg.src = "assets/mediumpinkcloud.png";

const mobImages = {};
for (const k of MOB_ORDER) {
  const img = new Image();
  img.src = `assets/${k}.png`;
  mobImages[k] = img;
}

const hudHp = document.getElementById("hudHp");
const hudTime = document.getElementById("hudTime");
const hudCombo = document.getElementById("hudCombo");
const hudSpr = document.getElementById("hudSpr");
const hudBnc = document.getElementById("hudBnc");
const hudDmg = document.getElementById("hudDmg");

const joyMove = document.getElementById("joyMove");
const joyAim = document.getElementById("joyAim");
const stickMove = document.getElementById("stickMove");
const stickAim = document.getElementById("stickAim");

const elementModal = document.getElementById("elementModal");
const pickFire = document.getElementById("pickFire");
const pickIce = document.getElementById("pickIce");
const pickThunder = document.getElementById("pickThunder");

const upgradeModal = document.getElementById("upgradeModal");
const upDesc = document.getElementById("upDesc");
const upElement = document.getElementById("upElement");
const upSpread = document.getElementById("upSpread");
const upBounce = document.getElementById("upBounce");
const upDamage = document.getElementById("upDamage");
const upHeal = document.getElementById("upHeal");
const upQueue = document.getElementById("upQueue");
upHeal.style.display = "none";

const gameOverModal = document.getElementById("gameOverModal");
const gameOverTitle = document.getElementById("gameOverTitle");
const result = document.getElementById("result");
const restartBtn = document.getElementById("restartBtn");
const finalBossModal = document.getElementById("finalBossModal");
const finalBossConfirm = document.getElementById("finalBossConfirm");

const W = () => canvas.width;
const H = () => canvas.height;
const rand = (a, b) => Math.random() * (b - a) + a;
const randi = (a, b) => Math.floor(rand(a, b + 1));
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

const inputMove = { x: 0, y: 0 };
const inputAim = { x: 0, y: 0 };

let moveTouchId = null;
let aimTouchId = null;
let moveCenter = { x: 0, y: 0 };
let aimCenter = { x: 0, y: 0 };
let moveRadius = 0;
let aimRadius = 0;
let lastTs = 0;
let enemyIdSeq = 1;

const bg = { starsA: [], starsB: [], fog: [] };

const game = {
  guaranteedPowerups: [false, false, false], // 10s / 30s / 50s
  player: null,
  enemies: [],
  playerBullets: [],
  enemyBullets: [],
  powerups: [],
  medkits: [],
  effects: { rings: [], lines: [], snow: [] },

  score: 0,
  time: 0,
  combo: 0,
  comboTimer: 0,

  spawnTimer: 0,
  bossTimer: 36,
  bossInterval: 24,
  bossCount: 0,

  over: false,
  paused: false,
  pendingPowerup: 0,
  firstPowerupGiven: false,
  curseActive: false,
  firstMedkitGiven: false,
  medkitTimer: 45,
  finalBossIntroOpen: false,
  finalBossSpawned: false,
  finalBossDefeated: false,
  inFinalBattle: false,

  element: null,
  upgrades: { elementLv: 0, spread: 0, bounce: 0, damage: 0 },

  frenzy: { time: 0, rateMul: 1.4, dmgMul: 1.25, milestone: 0 }
};

function initBackground() {
  bg.starsA = [];
  bg.starsB = [];
  bg.fog = [];
  for (let i = 0; i < 60; i++) bg.starsA.push({ x: rand(0, W()), y: rand(0, H()), s: rand(1, 2), v: rand(8, 18) });
  for (let i = 0; i < 35; i++) bg.starsB.push({ x: rand(0, W()), y: rand(0, H()), s: rand(2, 3), v: rand(20, 36) });
  for (let i = 0; i < 7; i++) bg.fog.push({ x: rand(0, W()), y: rand(0, H()), r: rand(60, 130), dx: rand(-8, 8), dy: rand(-8, 8) });
}

function circleHit(a, b) {
  const ar = a.hitR ?? a.r;
  const br = b.hitR ?? b.r;
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  const rr = ar + br;
  return dx * dx + dy * dy <= rr * rr;
}

function elementName(t) {
  if (t === "fire") return "火彈";
  if (t === "ice") return "冰彈";
  if (t === "thunder") return "雷彈";
  return "未選擇";
}

function currentMobKey() {
  const idx = Math.min(MOB_ORDER.length - 1, Math.floor(game.time / 30));
  return MOB_ORDER[idx];
}

function bossHpScaleByTime(t) {
  if (t >= 60) return 1;
  // First minute ramps from 62% to 100%.
  return 0.62 + (t / 60) * 0.38;
}

function bossSpawnIntervalByTime(t) {
  if (t < 60) return 30;
  if (t < 120) return 20;
  return 12;
}

class Player {
  constructor() {
    this.x = W() * 0.5;
    this.y = H() * 0.5;
    this.r = 12;
    this.hitR = 8.5;
    this.drawHalf = 14;
    this.bound = this.drawHalf + 2;

    this.maxHp = 200;
    this.hp = 200;
    this.baseSpeed = 250;
    this.speedMul = 1;

    this.fireCd = 0;
    this.fireInterval = 0.12;
    this.facing = -Math.PI / 2;

    this.flash = 0;
    this.invuln = 0;
    this.freeze = 0;
  }

  update(dt) {
    if (this.freeze <= 0) {
      const spd = this.baseSpeed * this.speedMul;
      this.x += inputMove.x * spd * dt;
      this.y += inputMove.y * spd * dt;

      if (Math.hypot(inputAim.x, inputAim.y) > 0.2) {
        const ad = getAimDir();
        this.facing = Math.atan2(ad.y, ad.x);
      }
    }

    this.x = clamp(this.x, this.bound, W() - this.bound);
    this.y = clamp(this.y, this.bound, H() - this.bound);

    this.fireCd -= dt;
    const frenzyRate = game.frenzy.time > 0 ? game.frenzy.rateMul : 1;
    if (this.fireCd <= 0 && !game.paused && !game.over) {
      const base = this.fireInterval * Math.max(0.45, 1 - game.upgrades.damage * 0.03);
      this.fireCd = base / frenzyRate;
      spawnPlayerBullets();
    }

    if (this.flash > 0) this.flash -= dt;
    if (this.invuln > 0) this.invuln -= dt;
    if (this.freeze > 0) this.freeze -= dt;
  }

  hurt(dmg) {
    if (this.invuln > 0 || game.over) return;
    const newbieProtect = game.time <= 30 ? 0.6 : 1;
    this.hp = Math.max(0, this.hp - dmg * newbieProtect);
    this.flash = 0.15;
    this.invuln = 0.25;
    resetCombo();

    if (this.hp <= 0) {
      if (game.inFinalBattle && !game.finalBossDefeated) endGame("finalLose");
      else endGame("normalLose");
    }
  }

  draw() {
    const s = this.drawHalf * 2;
    if (heroImg.complete && heroImg.naturalWidth) ctx.drawImage(heroImg, this.x - s / 2, this.y - s / 2, s, s);
    else {
      ctx.fillStyle = "#67d7ff";
      ctx.fillRect(this.x - 10, this.y - 10, 20, 20);
    }

    const fx = this.x + Math.cos(this.facing) * 16;
    const fy = this.y + Math.sin(this.facing) * 16;
    ctx.strokeStyle = this.freeze > 0 ? "#9ed8ff" : "#ffe58a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(fx, fy);
    ctx.stroke();

    if (this.flash > 0) {
      ctx.fillStyle = "rgba(255,64,64,.45)";
      ctx.fillRect(this.x - s / 2, this.y - s / 2, s, s);
    }
  }
}

class Enemy {
  constructor(opts) {
    this.id = enemyIdSeq++;
    this.isBoss = opts.isBoss;
    this.isFinalBoss = !!opts.isFinalBoss;
    this.bossIndex = opts.bossIndex || 0;
    this.isClone = !!opts.isClone;
    this.alive = true;

    this.touchCd = 0;
    this.freeze = 0;
    this.slowTimer = 0;
    this.slowMul = 1;

    this.pendingSpawn = [];
    this.lastLightningShot = 0;
    this.lightningWarn = 0;
    this.pendingLightningBurst = false;
    this.multiCd = 0.5;
    this.dashCd = rand(1.2, 2);
    this.dashTime = 0;
    this.dashVx = 0;
    this.dashVy = 0;
    this.teleportStep = 0;
    this.splitStage = 0;

    if (opts.copyData) {
      const c = opts.copyData;
      this.r = c.r;
      this.hitR = c.hitR;
      this.baseDamage = c.baseDamage;
      this.maxHp = c.maxHp;
      this.hp = c.hp;
      this.affixes = new Set(c.affixes);
      this.spriteKey = c.spriteKey;
      this.x = clamp(c.x + rand(-26, 26), this.r, W() - this.r);
      this.y = clamp(c.y + rand(-26, 26), this.r, H() - this.r);
      this.vx = rand(-110, 110);
      this.vy = rand(-110, 110);
      this.teleportStep = c.teleportStep;
      this.splitStage = c.splitStage;
      this.isClone = true;
      return;
    }

    if (!this.isBoss) {
      const st = MOB_STATS[opts.mobKey];
      this.spriteKey = opts.mobKey;
      this.r = st.size;
      this.hitR = st.size * 0.68;
      this.baseDamage = st.dmg;
      this.maxHp = st.hp + game.time * 0.02;
      this.hp = this.maxHp;
      this.affixes = new Set();
    } else {
      if (this.isFinalBoss) {
        this.spriteKey = "mediumpinkcloud";
        this.r = 30;
        this.hitR = 20;
        this.baseDamage = 12;
        this.maxHp = 2500;
        this.hp = this.maxHp;
        this.affixes = new Set(Object.values(AFFIX));
      } else {
        this.spriteKey = opts.bossSprite;
        this.r = 22;
        this.hitR = 14;
        this.baseDamage = 10;
        const rawBossHp = 55 + game.bossCount * 10 + game.time * 0.25;
        this.maxHp = rawBossHp * bossHpScaleByTime(game.time);
        this.hp = this.maxHp;
        this.affixes = new Set();
        this.assignBossAffixes();
      }
    }

    this.spawnFromEdge();
  }

  spawnFromEdge() {
    const edge = randi(0, 3);
    const base = this.isBoss ? rand(74, 96) : rand(60, 95);
    if (edge === 0) { this.x = rand(this.r, W() - this.r); this.y = this.r; this.vx = rand(-base, base); this.vy = rand(25, base); }
    if (edge === 1) { this.x = rand(this.r, W() - this.r); this.y = H() - this.r; this.vx = rand(-base, base); this.vy = -rand(25, base); }
    if (edge === 2) { this.x = this.r; this.y = rand(this.r, H() - this.r); this.vx = rand(25, base); this.vy = rand(-base, base); }
    if (edge === 3) { this.x = W() - this.r; this.y = rand(this.r, H() - this.r); this.vx = -rand(25, base); this.vy = rand(-base, base); }
  }

  affixCountByBossIndex(i) {
    if (game.time < 60) return 1;
    if (game.time < 120) return 2;
    return 3;
  }

  assignBossAffixes() {
  const count = this.affixCountByBossIndex(this.bossIndex);

  let pool = [
    AFFIX.TANK, AFFIX.FAST, AFFIX.CURSE, AFFIX.FIRE, AFFIX.ICE,
    AFFIX.LIGHTNING, AFFIX.DASH, AFFIX.MULTI, AFFIX.TELEPORT, AFFIX.SPLIT
  ];

  // 2分鐘前不允許出現多重射擊
  if (game.time < 120) {
    pool = pool.filter(k => k !== AFFIX.MULTI);
  }

  while (this.affixes.size < count) {
    const k = pool[randi(0, pool.length - 1)];
    if (k === AFFIX.FIRE && this.affixes.has(AFFIX.ICE)) continue;
    if (k === AFFIX.ICE && this.affixes.has(AFFIX.FIRE)) continue;
    this.affixes.add(k);
  }

  if (this.affixes.has(AFFIX.TANK)) this.maxHp *= 1.5;
  if (this.affixes.has(AFFIX.TANK)) {
    this.r *= 1.5;
    this.hitR *= 1.5;
  }
  this.hp = this.maxHp;
}

hasAffix(k) { return this.isBoss && this.affixes.has(k); }
getDamage() { return this.baseDamage * (this.hasAffix(AFFIX.TANK) ? 2 : 1); }

applyIceSlow(level) {
  const cappedLv = Math.min(level, 4);
  const slowPct = 0.2 + Math.max(0, cappedLv - 1) * 0.2;
  const mul = 1 - Math.min(0.8, slowPct);
  this.slowMul = Math.min(this.slowMul, mul);
  this.slowTimer = Math.max(this.slowTimer, 1.0);
}

  onHitByPlayer(dmg) {
    if (!this.alive) return;

    if (this.hasAffix(AFFIX.LIGHTNING) && game.time - this.lastLightningShot >= 0.3) {
      this.lastLightningShot = game.time;
      this.pendingLightningBurst = true;
      this.lightningWarn = Math.max(this.lightningWarn, 0.2);
    }

    this.hp -= dmg;

    if (this.hasAffix(AFFIX.TELEPORT) && this.hp > 0) {
      while (this.teleportStep < 4 && this.hp <= this.maxHp * (1 - (this.teleportStep + 1) / 5)) {
        this.teleportStep++;
        this.x = rand(this.r, W() - this.r);
        this.y = rand(this.r, H() - this.r);
      }
    }

    if (this.hasAffix(AFFIX.SPLIT) && this.hp > 0) {
      if (this.splitStage === 0 && this.hp <= this.maxHp * 0.5) this.splitNow(1);
      if (this.splitStage === 1 && this.hp <= this.maxHp * 0.25) this.splitNow(2);
    }

    if (this.hp <= 0) this.die();
  }

  splitNow(stage) {
    this.splitStage = stage;
    this.r *= 0.82;
    this.hitR *= 0.82;
    this.pendingSpawn.push(new Enemy({
      isBoss: true,
      bossIndex: this.bossIndex,
      isClone: true,
      copyData: {
        x: this.x, y: this.y, r: this.r, hitR: this.hitR, maxHp: this.maxHp, hp: this.hp,
        baseDamage: this.baseDamage, affixes: [...this.affixes], spriteKey: this.spriteKey,
        teleportStep: this.teleportStep, splitStage: this.splitStage
      }
    }));
  }

  die() {
    if (!this.alive) return;
    this.alive = false;
    addScore(this.isBoss ? 35 : 4);

    if (this.isFinalBoss && !this.isClone) {
      game.finalBossDefeated = true;
      endGame("finalWin");
      return;
    }

    // 只有Boss本體掉落
    if (this.isBoss && !this.isClone) {
      let dropCount = 1;
      if (game.time >= 120) {
        const roll = Math.random();
        if (roll < 0.2) dropCount = 3;
        else if (roll < 0.7) dropCount = 2;
      }
      for (let i = 0; i < dropCount; i++) {
        game.powerups.push({
          x: clamp(this.x + rand(-24, 24), 20, W() - 20),
          y: clamp(this.y + rand(-24, 24), 20, H() - 20),
          r: 16,
          hitR: 13,
          ttl: 16,
          text: "POWERUP"
        });
      }
    }

    if (this.hasAffix(AFFIX.FIRE)) {
      const r = 86;
      game.effects.rings.push({ x: this.x, y: this.y, r: 0, maxR: r, life: 0.34, color: "255,80,60" });
      game.effects.rings.push({ x: this.x, y: this.y, r: 0, maxR: r * 0.72, life: 0.26, color: "255,170,90" });
      if (Math.hypot(game.player.x - this.x, game.player.y - this.y) <= r + game.player.hitR) game.player.hurt(this.getDamage());
    }

    if (this.hasAffix(AFFIX.ICE)) {
      const r = 96;
      game.effects.rings.push({ x: this.x, y: this.y, r: 0, maxR: r, life: 0.36, color: "130,210,255" });
      game.effects.rings.push({ x: this.x, y: this.y, r: 0, maxR: r * 0.74, life: 0.28, color: "200,245,255" });
      if (Math.hypot(game.player.x - this.x, game.player.y - this.y) <= r + game.player.hitR) {
        game.player.hurt(this.getDamage() * 0.8);
        game.player.freeze = Math.max(game.player.freeze, 3);
      }
    }
  }

  update(dt) {
    if (!this.alive) return;
    if (this.touchCd > 0) this.touchCd -= dt;
    if (this.freeze > 0) this.freeze -= dt;
    if (this.slowTimer > 0) this.slowTimer -= dt;
    if (this.slowTimer <= 0) this.slowMul = 1;
    if (this.lightningWarn > 0) {
      this.lightningWarn -= dt;
      if (this.lightningWarn <= 0 && this.pendingLightningBurst) {
        this.pendingLightningBurst = false;
        const sp = 250;
        for (let i = 0; i < 8; i++) {
          const a = i * (Math.PI * 2 / 8);
          game.enemyBullets.push({
            x: this.x,
            y: this.y,
            vx: Math.cos(a) * sp,
            vy: Math.sin(a) * sp,
            r: 4.8,
            hitR: 4.2,
            life: 2.4,
            dmg: 4,
            color: "rgba(145,215,255,.98)",
            swirl: true,
            ox: this.x,
            oy: this.y,
            dirx: Math.cos(a),
            diry: Math.sin(a),
            speed: sp,
            t: 0,
            swirlR: 11,
            swirlW: 14.5,
            phase: rand(0, Math.PI * 2)
          });
        }
      }
    }

    if (this.freeze <= 0) {
      const dx = game.player.x - this.x;
      const dy = game.player.y - this.y;
      const d = Math.hypot(dx, dy) || 1;

      if (this.isBoss && this.hasAffix(AFFIX.DASH)) {
        this.dashCd -= dt;
        if (this.dashCd <= 0 && this.dashTime <= 0) {
          this.dashCd = 2;
          this.dashTime = 0.22;
          const ux = dx / d;
          const uy = dy / d;
          const dashSp = 540;
          this.dashVx = ux * dashSp;
          this.dashVy = uy * dashSp;
          game.effects.lines.push({ x1: this.x, y1: this.y, x2: this.x + ux * 72, y2: this.y + uy * 72, life: 0.14, color: "255,120,120" });
          game.effects.rings.push({ x: this.x, y: this.y, r: 0, maxR: 28, life: 0.12, color: "255,120,120" });
        }
      }

      if (this.dashTime > 0) {
        this.dashTime -= dt;
        this.x += this.dashVx * dt;
        this.y += this.dashVy * dt;
      } else {
        let home = this.isBoss ? 20 : 14;
        if (this.hasAffix(AFFIX.FAST)) home *= 1.8;

        this.vx += (dx / d) * home * dt;
        this.vy += (dy / d) * home * dt;

        let maxSp = this.isBoss ? 120 : 145;
        if (this.hasAffix(AFFIX.FAST)) maxSp *= 2;
        maxSp *= this.slowMul;

        const cur = Math.hypot(this.vx, this.vy) || 1;
        if (cur > maxSp) {
          this.vx = this.vx / cur * maxSp;
          this.vy = this.vy / cur * maxSp;
        }

        this.x += this.vx * dt;
        this.y += this.vy * dt;
      }
    }

    if (this.x < this.r) { this.x = this.r; this.vx = Math.abs(this.vx); }
    if (this.x > W() - this.r) { this.x = W() - this.r; this.vx = -Math.abs(this.vx); }
    if (this.y < this.r) { this.y = this.r; this.vy = Math.abs(this.vy); }
    if (this.y > H() - this.r) { this.y = H() - this.r; this.vy = -Math.abs(this.vy); }

    if (this.isBoss) {
      this.multiCd -= dt;
      if (this.multiCd <= 0) {
        this.multiCd = 0.5;
        const base = Math.atan2(game.player.y - this.y, game.player.x - this.x);
        const spread = this.hasAffix(AFFIX.MULTI) ? [-0.18, 0, 0.18] : [0];
        spread.forEach(off => {
          const a = base + off, sp = 260;
          game.enemyBullets.push({ x: this.x, y: this.y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, r: 4, hitR: 3.5, life: 2.6, dmg: 5, color: "rgba(255,180,120,.95)" });
        });
      }
    }
  }

  draw() {
    const s = this.r * 2.1;
    const x = this.x - s / 2;
    const y = this.y - s / 2;
    const img = this.spriteKey === "mediumpinkcloud" ? finalBossImg : mobImages[this.spriteKey];

    if (img && img.complete && img.naturalWidth) ctx.drawImage(img, x, y, s, s);
    else {
      ctx.fillStyle = this.isBoss ? "#ff9c9c" : "#84ff95";
      ctx.fillRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
    }

    if (this.slowTimer > 0) {
      ctx.fillStyle = "rgba(120,200,255,.25)";
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r + 2, 0, Math.PI * 2);
      ctx.fill();
    }

    if (this.isBoss) {
      if (this.hasAffix(AFFIX.FIRE) || this.hasAffix(AFFIX.ICE)) {
        const rr = this.hasAffix(AFFIX.ICE) ? 96 : 86;
        const c = this.hasAffix(AFFIX.ICE) ? "130,210,255" : "255,90,70";
        const pulse = 0.18 + (Math.sin(game.time * 12 + this.id) + 1) * 0.2;
        ctx.strokeStyle = `rgba(${c},${pulse})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, rr, 0, Math.PI * 2);
        ctx.stroke();
      }

      if (this.hasAffix(AFFIX.LIGHTNING) && this.lightningWarn > 0) {
        const t = this.lightningWarn / 0.2;
        const a = 0.35 + (1 - t) * 0.45;
        ctx.strokeStyle = `rgba(170,230,255,${a})`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
          const ang = i * Math.PI / 4;
          const len = 26 + (1 - t) * 18;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(this.x + Math.cos(ang) * len, this.y + Math.sin(ang) * len);
          ctx.stroke();
        }
      }

      ctx.fillStyle = "#000";
      ctx.fillRect(this.x - 34, this.y - this.r - 12, 68, 5);
      ctx.fillStyle = "#ff6565";
      ctx.fillRect(this.x - 34, this.y - this.r - 12, 68 * Math.max(0, this.hp / this.maxHp), 5);

      const labels = [...this.affixes].map(k => AFFIX_ZH[k]).filter(Boolean);
      if (labels.length) {
        const text = labels.join("｜");
        ctx.font = "bold 11px monospace";
        ctx.textAlign = "center";
        const tw = ctx.measureText(text).width + 10;
        const by = this.y - this.r - 30;
        ctx.fillStyle = "rgba(0,0,0,.68)";
        ctx.fillRect(this.x - tw / 2, by, tw, 16);
        ctx.fillStyle = "#ffe79c";
        ctx.fillText(text, this.x, by + 12);
      }
    }
  }
}

function getAimDir() {
  const len = Math.hypot(inputAim.x, inputAim.y);
  const base = len > 0.2
    ? { x: inputAim.x / len, y: inputAim.y / len }
    : { x: Math.cos(game.player.facing), y: Math.sin(game.player.facing) };

  if (len <= 0.2) return base;

  const assistRange = 340;
  const assistConeCos = Math.cos(Math.PI / 3.3); // about 54deg
  let target = null;
  let bestScore = -1e9;

  for (const e of game.enemies) {
    if (!e.alive) continue;
    const dx = e.x - game.player.x;
    const dy = e.y - game.player.y;
    const d = Math.hypot(dx, dy) || 1;
    if (d > assistRange) continue;

    const nx = dx / d;
    const ny = dy / d;
    const dot = nx * base.x + ny * base.y;
    if (dot < assistConeCos) continue;

    const score = dot * 1.35 + (1 - d / assistRange) * 0.9;
    if (score > bestScore) {
      bestScore = score;
      target = { x: nx, y: ny };
    }
  }

  if (!target) return base;

  const assistStrength = 0.48;
  const mx = base.x * (1 - assistStrength) + target.x * assistStrength;
  const my = base.y * (1 - assistStrength) + target.y * assistStrength;
  const ml = Math.hypot(mx, my) || 1;
  return { x: mx / ml, y: my / ml };
}

function spawnPlayerBullets() {
  const rows = 1 + game.upgrades.spread;
  const sp = 680;

  const dir = getAimDir();
  const baseAngle = Math.atan2(dir.y, dir.x);
  const spreadLv = game.upgrades.spread;
  const maxAngle = Math.PI * 2 / 3; // 120deg
  const totalAngle = spreadLv <= 10 ? maxAngle * (spreadLv / 10) : maxAngle;
  const frenzy = game.frenzy.time > 0 ? game.frenzy.dmgMul : 1;
  const iceExtra = game.element === "ice" ? Math.max(0, game.upgrades.elementLv - 4) : 0;
  const bulletR = 5 + iceExtra * 0.8;
  const bulletHitR = bulletR * 0.84;

  for (let i = 0; i < rows; i++) {
    const t = rows === 1 ? 0.5 : i / (rows - 1);
    const rel = (t - 0.5) * totalAngle;
    const a = baseAngle + rel;
    game.playerBullets.push({
      x: game.player.x,
      y: game.player.y,
      vx: Math.cos(a) * sp,
      vy: Math.sin(a) * sp,
      r: bulletR,
      hitR: bulletHitR,
      alive: true,
      bounceLeft: game.upgrades.bounce,
      dmg: (1 + game.upgrades.damage * 0.35) * frenzy
    });
  }
}

function spawnEnemy() {
  game.enemies.push(new Enemy({ isBoss: false, mobKey: currentMobKey() }));
}
function randomBossSprite() {
  return MOB_ORDER[randi(0, MOB_ORDER.length - 1)];
}
function spawnBoss() {
  game.bossCount++;
  game.enemies.push(new Enemy({ isBoss: true, bossIndex: game.bossCount, bossSprite: randomBossSprite() }));
}

function showFinalBossIntro() {
  if (game.finalBossSpawned || game.finalBossIntroOpen || game.over) return;
  game.finalBossIntroOpen = true;
  game.paused = true;
  finalBossModal.style.display = "flex";
}

function spawnFinalBoss() {
  if (game.finalBossSpawned || game.over) return;
  game.enemies = [];
  game.enemyBullets = [];
  game.playerBullets = [];
  game.effects = { rings: [], lines: [], snow: [] };
  game.bossCount++;
  game.enemies.push(new Enemy({ isBoss: true, isFinalBoss: true, bossIndex: game.bossCount }));
  game.finalBossSpawned = true;
  game.inFinalBattle = true;
  game.bossTimer = 999999;
}

function spawnPattern(t) {
  if (t < 20) return { interval: 1.55, count: 1, maxAlive: 8 };
  if (t < 40) return { interval: 1.30, count: 1, maxAlive: 10 };
  if (t < 60) return { interval: 1.10, count: 1, maxAlive: 12 };

  if (t < 100) return { interval: 0.82, count: 2, maxAlive: 22 };
  if (t < 150) return { interval: 0.62, count: 3, maxAlive: 30 };
  return { interval: 0.46, count: 3 + Math.floor((t - 150) / 45), maxAlive: 42 };
}

function addScore(base) {
  game.combo = game.comboTimer > 0 ? game.combo + 1 : 1;
  game.comboTimer = 2;

  const m = Math.floor(game.combo / 10);
  if (m > game.frenzy.milestone) {
    game.frenzy.milestone = m;
    game.frenzy.time = 6;
  }

  const cm = 1 + Math.min(3, game.combo * 0.08);
  const dm = 1 + (1 - game.player.hp / game.player.maxHp) * 0.55;
  game.score += Math.round(base * cm * dm);
}

function resetCombo() {
  game.combo = 0;
  game.comboTimer = 0;
  game.frenzy.milestone = 0;
}

function buildGameOverSummary() {
  const lines = [
    `存活時間：${game.time.toFixed(1)} 秒`,
    `分數：${game.score}`,
    `屬性彈：${elementName(game.element)}`,
    `屬性等級：Lv${game.upgrades.elementLv}`,
    `散射：Lv${game.upgrades.spread}`,
    `彈射：Lv${game.upgrades.bounce}`,
    `重擊：Lv${game.upgrades.damage}`
  ];
  return lines.join("\n");
}

function endGame(type) {
  if (game.over) return;
  game.over = true;
  game.paused = true;
  elementModal.style.display = "none";
  upgradeModal.style.display = "none";
  finalBossModal.style.display = "none";

  if (type === "finalWin") {
    gameOverTitle.textContent = "Victory";
    result.textContent = `粉紅雲：等、等等……這怎麼可能……\n\n遊戲結束，恭喜破關`;
  } else if (type === "finalLose") {
    gameOverTitle.textContent = "GAME OVER";
    result.textContent = `粉紅雲：\n你已經很努力了，\n不過嘛——努力不代表會贏~\n\n遊戲結束`;
  } else {
    gameOverTitle.textContent = "GAME OVER";
    result.textContent = buildGameOverSummary();
  }
  gameOverModal.style.display = "flex";
}

function findNearestEnemy(x, y, excludeSet, range) {
  let best = null;
  let bestD = range;
  for (const e of game.enemies) {
    if (!e.alive || excludeSet.has(e.id)) continue;
    const d = Math.hypot(e.x - x, e.y - y);
    if (d < bestD) { best = e; bestD = d; }
  }
  return best;
}

function makeLightningPoints(x1, y1, x2, y2, segments = 7, amp = 11) {
  const pts = [{ x: x1, y: y1 }];
  const dx = x2 - x1;
  const dy = y2 - y1;
  const len = Math.hypot(dx, dy) || 1;
  const nx = -dy / len;
  const ny = dx / len;
  for (let i = 1; i < segments; i++) {
    const t = i / segments;
    const baseX = x1 + dx * t;
    const baseY = y1 + dy * t;
    const edgeFade = 1 - Math.abs(t - 0.5) * 1.55;
    const off = rand(-amp, amp) * Math.max(0.2, edgeFade);
    pts.push({ x: baseX + nx * off, y: baseY + ny * off });
  }
  pts.push({ x: x2, y: y2 });
  return pts;
}

function spawnIceField(x, y, lv) {
  if (lv < 3) return;
  const r = 34 + lv * 5;
  const dot = 0.28 + lv * 0.16;
  const slowLv = Math.max(1, lv - 1);

  let merged = null;
  for (const s of game.effects.snow) {
    if (Math.hypot(s.x - x, s.y - y) <= (s.r + r) * 0.45) {
      merged = s;
      break;
    }
  }

  if (merged) {
    merged.life = Math.max(merged.life, 3);
    merged.r = Math.min(92, Math.max(merged.r, r + 4));
    merged.dot = Math.max(merged.dot, dot);
    merged.slowLv = Math.max(merged.slowLv, slowLv);
    merged.tick = Math.min(merged.tick, 0.2);
  } else {
    game.effects.snow.push({
      x, y,
      r,
      life: 3,
      tick: 0.25,
      dot,
      slowLv,
      phase: rand(0, Math.PI * 2)
    });
  }
}

function applyElementEffect(hit) {
  const lv = Math.max(1, game.upgrades.elementLv);

  if (game.element === "fire") {
    const r = 72 + lv * 12;
    const dmg = 0.7 + lv * 0.35;
    hit.onHitByPlayer(dmg);
    game.effects.rings.push({ x: hit.x, y: hit.y, r: 0, maxR: r, life: 0.24, color: "255,90,70" });
    game.effects.rings.push({ x: hit.x, y: hit.y, r: 0, maxR: r * 0.72, life: 0.20, color: "255,210,110" });
    for (let i = 0; i < 7; i++) {
      const a = rand(0, Math.PI * 2);
      const d = rand(16, r * 0.95);
      game.effects.lines.push({
        x1: hit.x,
        y1: hit.y,
        x2: hit.x + Math.cos(a) * d,
        y2: hit.y + Math.sin(a) * d,
        life: 0.14,
        color: "255,150,90"
      });
    }
    for (const e of game.enemies) {
      if (!e.alive || e.id === hit.id) continue;
      if (Math.hypot(e.x - hit.x, e.y - hit.y) <= r + e.hitR) e.onHitByPlayer(dmg);
    }
  }

  if (game.element === "ice") {
    hit.applyIceSlow(lv);
    if (lv >= 3) {
      // Tuned for practical Lv3~Lv5 progression.
      const frostDmg = 1.1 + (lv - 3) * 0.75;
      hit.onHitByPlayer(frostDmg);

      // Root chance scales with level; capped to avoid perma-lock.
      const rootChance = Math.min(0.5, 0.18 + (lv - 3) * 0.12);
      if (Math.random() < rootChance) {
        const rootTime = Math.min(1.1, 0.4 + (lv - 3) * 0.1);
        hit.freeze = Math.max(hit.freeze, rootTime);
        game.effects.rings.push({ x: hit.x, y: hit.y, r: 0, maxR: 34 + lv * 3, life: 0.2, color: "185,240,255" });
      }

      // Shatter splash: gives ice better wave clear.
      const shatterR = 24 + lv * 6;
      const shatterDmg = 0.25 + lv * 0.18;
      game.effects.rings.push({ x: hit.x, y: hit.y, r: 0, maxR: shatterR, life: 0.14, color: "200,245,255" });
      for (const e of game.enemies) {
        if (!e.alive || e.id === hit.id) continue;
        if (Math.hypot(e.x - hit.x, e.y - hit.y) <= shatterR + e.hitR) e.onHitByPlayer(shatterDmg);
      }

      // Lv3+ creates snowy ground for 3s that keeps applying frostbite.
      spawnIceField(hit.x, hit.y, lv);
    }

    const ir = 20 + lv * 4;
    game.effects.rings.push({ x: hit.x, y: hit.y, r: 0, maxR: ir, life: 0.2, color: "120,200,255" });
    game.effects.rings.push({ x: hit.x, y: hit.y, r: 0, maxR: ir * 0.65, life: 0.16, color: "210,245,255" });
    for (let i = 0; i < 6; i++) {
      const a = i * (Math.PI * 2 / 6) + rand(-0.12, 0.12);
      const d = ir * rand(0.55, 0.95);
      game.effects.lines.push({
        x1: hit.x,
        y1: hit.y,
        x2: hit.x + Math.cos(a) * d,
        y2: hit.y + Math.sin(a) * d,
        life: 0.16,
        color: "170,230,255"
      });
    }
  }

  if (game.element === "thunder") {
    let jumps = 1 + lv;
    const range = 90 + lv * 18;
    const dmg = 0.55 + lv * 0.16;
    const used = new Set([hit.id]);
    let from = hit;

    while (jumps > 0) {
      const n = findNearestEnemy(from.x, from.y, used, range);
      if (!n) break;
      used.add(n.id);
      game.effects.lines.push({
        x1: from.x,
        y1: from.y,
        x2: n.x,
        y2: n.y,
        life: 0.12,
        color: "190,230,255",
        points: makeLightningPoints(from.x, from.y, n.x, n.y, 7, 11 + lv * 1.2)
      });
      n.onHitByPlayer(dmg);
      from = n;
      jumps--;
    }
  }
}

function updatePlayerBullets(dt) {
  for (const b of game.playerBullets) {
    if (!b.alive) continue;
    b.x += b.vx * dt;
    b.y += b.vy * dt;

    if (b.x < -40 || b.x > W() + 40 || b.y < -40 || b.y > H() + 40) {
      b.alive = false;
      continue;
    }

    for (const e of game.enemies) {
      if (!e.alive || !circleHit(b, e)) continue;

      e.onHitByPlayer(b.dmg);
      if (game.element) applyElementEffect(e);

      let bounced = false;
      if (b.bounceLeft > 0) {
        const t = findNearestEnemy(e.x, e.y, new Set([e.id]), 220);
        if (t) {
          const dx = t.x - e.x, dy = t.y - e.y;
          const d = Math.hypot(dx, dy) || 1;
          const sp = 680;
          b.vx = dx / d * sp;
          b.vy = dy / d * sp;
          b.x = e.x;
          b.y = e.y;
          b.bounceLeft--;
          b.dmg *= 0.88;
          bounced = true;
          game.effects.lines.push({ x1: e.x, y1: e.y, x2: t.x, y2: t.y, life: 0.08, color: "255,255,190" });
        }
      }

      if (!bounced) b.alive = false;
      break;
    }
  }
  game.playerBullets = game.playerBullets.filter(b => b.alive);
}

function updateEnemyBullets(dt) {
  for (const b of game.enemyBullets) {
    if (b.swirl) {
      b.t += dt;
      const cx = b.ox + b.dirx * b.speed * b.t;
      const cy = b.oy + b.diry * b.speed * b.t;
      const w = b.phase + b.swirlW * b.t;
      b.x = cx + Math.cos(w) * b.swirlR;
      b.y = cy + Math.sin(w) * b.swirlR;
    } else {
      b.x += b.vx * dt;
      b.y += b.vy * dt;
    }
    b.life -= dt;

    if (b.life <= 0 || b.x < -40 || b.x > W() + 40 || b.y < -40 || b.y > H() + 40) b.dead = true;
    if (!b.dead && circleHit(b, game.player)) {
      game.player.hurt(b.dmg);
      b.dead = true;
    }
  }
  game.enemyBullets = game.enemyBullets.filter(b => !b.dead);
}

function updateEnemies(dt) {
  let curse = false;
  const add = [];

  for (const e of game.enemies) {
    if (!e.alive) continue;

    e.update(dt);
    if (e.pendingSpawn.length) {
      add.push(...e.pendingSpawn);
      e.pendingSpawn.length = 0;
    }

    if (e.isBoss && e.hasAffix(AFFIX.CURSE)) curse = true;

    if (circleHit(e, game.player) && e.touchCd <= 0) {
      e.touchCd = e.isBoss ? 0.85 : 0.65;
      game.player.hurt(e.getDamage());
    }
  }

  if (add.length) game.enemies.push(...add);
  game.curseActive = curse;
  game.player.speedMul = curse ? 0.7 : 1;
  game.enemies = game.enemies.filter(e => e.alive);
}

function updatePowerups(dt) {
  const times = [10, 30, 50];
  for (let i = 0; i < times.length; i++) {
    if (!game.guaranteedPowerups[i] && game.time >= times[i]) {
      game.guaranteedPowerups[i] = true;
      game.powerups.push({
        x: W() * (0.3 + i * 0.2),
        y: H() * 0.35,
        r: 16,
        hitR: 13,
        ttl: 18,
        text: "POWERUP"
      });
    }
  }

  for (const p of game.powerups) {
    p.ttl -= dt;
    p.y += 8 * dt;
    if (circleHit(p, game.player)) {
      p.ttl = -1;
      game.pendingPowerup++;
      openNextSelection();
    }
  }
  game.powerups = game.powerups.filter(p => p.ttl > 0);
}

function spawnMedkit() {
  game.medkits.push({
    x: rand(42, W() - 42),
    y: rand(42, H() - 42),
    r: 16,
    hitR: 13,
    ttl: 45,
    text: "HP"
  });
}

function nextMedkitIntervalByHp(hp) {
  if (hp < 40) return rand(5, 12);
  if (hp < 70) return rand(7, 18);
  if (hp < 100) return rand(10, 26);
  return rand(15, 40);
}

function updateMedkits(dt) {
  if (!game.firstMedkitGiven && game.time >= 20) {
    game.firstMedkitGiven = true;
    spawnMedkit();
  }

  game.medkitTimer -= dt;
  if (game.medkitTimer <= 0) {
    const hp = game.player.hp;
    // In danger zone, avoid flooding by limiting to 2 on field.
    if (hp < 40 && game.medkits.length >= 2) {
      game.medkitTimer = rand(3, 7);
    } else {
      game.medkitTimer = nextMedkitIntervalByHp(hp);
      spawnMedkit();
    }
  }

  for (const m of game.medkits) {
    m.ttl -= dt;
    m.y += Math.sin((game.time + m.x) * 2.2) * 0.12;
    if (circleHit(m, game.player)) {
      m.ttl = -1;
      game.player.hp = Math.min(game.player.maxHp, game.player.hp + 50);
      game.effects.rings.push({ x: game.player.x, y: game.player.y, r: 0, maxR: 44, life: 0.26, color: "120,255,145" });
    }
  }
  game.medkits = game.medkits.filter(m => m.ttl > 0);
}


function updateEffects(dt) {
  if (game.frenzy.time > 0) game.frenzy.time -= dt;
  for (const r of game.effects.rings) { r.life -= dt; r.r += (r.maxR / 0.22) * dt; }
  for (const l of game.effects.lines) l.life -= dt;
  for (const s of game.effects.snow) {
    s.life -= dt;
    s.tick -= dt;
    while (s.tick <= 0) {
      s.tick += 0.4;
      for (const e of game.enemies) {
        if (!e.alive) continue;
        if (Math.hypot(e.x - s.x, e.y - s.y) <= s.r + e.hitR) {
          e.applyIceSlow(s.slowLv);
          e.onHitByPlayer(s.dot);
        }
      }
    }
  }
  game.effects.rings = game.effects.rings.filter(r => r.life > 0);
  game.effects.lines = game.effects.lines.filter(l => l.life > 0);
  game.effects.snow = game.effects.snow.filter(s => s.life > 0);
}

function updateBackground(dt) {
  for (const s of bg.starsA) { s.y += s.v * dt; if (s.y > H() + 2) { s.y = -2; s.x = rand(0, W()); } }
  for (const s of bg.starsB) { s.y += s.v * dt; if (s.y > H() + 3) { s.y = -3; s.x = rand(0, W()); } }
  for (const f of bg.fog) {
    f.x += f.dx * dt;
    f.y += f.dy * dt;
    if (f.x < -f.r) f.x = W() + f.r;
    if (f.x > W() + f.r) f.x = -f.r;
    if (f.y < -f.r) f.y = H() + f.r;
    if (f.y > H() + f.r) f.y = -f.r;
  }
}

function openNextSelection() {
  if (game.pendingPowerup <= 0 || game.over) return;
  game.paused = true;
  if (!game.element) elementModal.style.display = "flex";
  else {
    refreshUpgradeButtons();
    upgradeModal.style.display = "flex";
  }
}

function closeSelectionAndContinue() {
  if (game.pendingPowerup > 0) openNextSelection();
  else {
    game.paused = false;
    elementModal.style.display = "none";
    upgradeModal.style.display = "none";
  }
}

function chooseElement(type) {
  game.element = type;
  game.upgrades.elementLv = 1;
  game.pendingPowerup--;
  elementModal.style.display = "none";
  closeSelectionAndContinue();
}

function refreshUpgradeButtons() {
  const lv = game.upgrades.elementLv;
  const n = elementName(game.element);
  upDesc.textContent = `目前屬性：${n}`;
  upElement.textContent = `${n} 強化 Lv${lv} -> Lv${lv + 1}`;
  upSpread.textContent = `散射 Lv${game.upgrades.spread}：多一排子彈`;
  upBounce.textContent = `彈射 Lv${game.upgrades.bounce}：命中後再彈一次`;
  upDamage.textContent = `重擊 Lv${game.upgrades.damage}：子彈傷害提升`;
  upHeal.style.display = "none";
  upQueue.textContent = `待選升級：${game.pendingPowerup}`;
}

function chooseUpgrade(type) {
  if (type === "element") game.upgrades.elementLv++;
  if (type === "spread") game.upgrades.spread++;
  if (type === "bounce") game.upgrades.bounce++;
  if (type === "damage") game.upgrades.damage++;

  game.pendingPowerup--;
  if (game.pendingPowerup > 0) refreshUpgradeButtons();
  else {
    upgradeModal.style.display = "none";
    closeSelectionAndContinue();
  }
}

function drawBackground() {
  const g = ctx.createLinearGradient(0, 0, 0, H());
  g.addColorStop(0, "#0b1120");
  g.addColorStop(1, "#152743");
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W(), H());

  for (const f of bg.fog) {
    const rg = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.r);
    rg.addColorStop(0, "rgba(80,120,180,0.10)");
    rg.addColorStop(1, "rgba(80,120,180,0)");
    ctx.fillStyle = rg;
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.strokeStyle = "rgba(180,220,255,0.06)";
  ctx.lineWidth = 1;
  const gap = 46;
  const ox = (game.time * 8) % gap;
  const oy = (game.time * 10) % gap;
  for (let x = -gap; x < W() + gap; x += gap) {
    ctx.beginPath(); ctx.moveTo(x + ox, 0); ctx.lineTo(x + ox, H()); ctx.stroke();
  }
  for (let y = -gap; y < H() + gap; y += gap) {
    ctx.beginPath(); ctx.moveTo(0, y + oy); ctx.lineTo(W(), y + oy); ctx.stroke();
  }

  ctx.fillStyle = "rgba(220,240,255,0.45)";
  for (const s of bg.starsA) ctx.fillRect(s.x, s.y, s.s, s.s);
  ctx.fillStyle = "rgba(220,240,255,0.8)";
  for (const s of bg.starsB) ctx.fillRect(s.x, s.y, s.s, s.s);
}

function drawBullets() {
  for (const b of game.playerBullets) {
    const s = 12;
    if (bulletImg.complete && bulletImg.naturalWidth) ctx.drawImage(bulletImg, b.x - s / 2, b.y - s / 2, s, s);
    else { ctx.fillStyle = "#ffe889"; ctx.fillRect(b.x - 2, b.y - 6, 4, 12); }
  }

  for (const b of game.enemyBullets) {
    ctx.fillStyle = b.color || "rgba(120,190,255,.95)";
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();
  }
}

function drawPowerups() {
  for (const p of game.powerups) {
    ctx.textAlign = "center";
    ctx.font = "bold 15px monospace";
    ctx.fillStyle = "#ffd963";
    ctx.fillText(p.text, p.x, p.y);
  }
}

function drawMedkits() {
  for (const m of game.medkits) {
    const pulse = 0.5 + (Math.sin(game.time * 5 + m.x) + 1) * 0.2;
    ctx.textAlign = "center";
    ctx.font = "bold 18px monospace";
    ctx.fillStyle = `rgba(20,55,28,${pulse})`;
    ctx.beginPath();
    ctx.arc(m.x, m.y - 6, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#7bff9d";
    ctx.fillText(m.text, m.x, m.y + 1);
    ctx.strokeStyle = `rgba(130,255,165,${pulse + 0.15})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(m.x, m.y - 6, 18, 0, Math.PI * 2);
    ctx.stroke();
  }
}

function drawEffects() {
  for (const s of game.effects.snow) {
    const a = Math.max(0, s.life / 3);
    const rg = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.r);
    rg.addColorStop(0, `rgba(190,240,255,${0.16 * a})`);
    rg.addColorStop(0.7, `rgba(120,200,235,${0.2 * a})`);
    rg.addColorStop(1, "rgba(120,200,235,0)");
    ctx.fillStyle = rg;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fill();

    const pulse = 0.15 + (Math.sin(game.time * 7 + s.phase) + 1) * 0.1;
    ctx.strokeStyle = `rgba(200,245,255,${(pulse + 0.1) * a})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r * (0.92 + pulse * 0.22), 0, Math.PI * 2);
    ctx.stroke();

    ctx.strokeStyle = `rgba(225,250,255,${0.45 * a})`;
    ctx.lineWidth = 1.5;
    for (let i = 0; i < 6; i++) {
      const ang = s.phase + i * (Math.PI * 2 / 6);
      const d1 = s.r * 0.25;
      const d2 = s.r * 0.42;
      ctx.beginPath();
      ctx.moveTo(s.x + Math.cos(ang) * d1, s.y + Math.sin(ang) * d1);
      ctx.lineTo(s.x + Math.cos(ang) * d2, s.y + Math.sin(ang) * d2);
      ctx.stroke();
    }
  }

  for (const r of game.effects.rings) {
    const a = Math.max(0, r.life / 0.22);
    ctx.strokeStyle = `rgba(${r.color},${a})`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2); ctx.stroke();
  }

  for (const l of game.effects.lines) {
    const a = Math.max(0, l.life / 0.1);
    ctx.strokeStyle = `rgba(${l.color},${a})`;
    ctx.lineWidth = 2;
    if (l.points && l.points.length > 1) {
      ctx.beginPath();
      ctx.moveTo(l.points[0].x, l.points[0].y);
      for (let i = 1; i < l.points.length; i++) ctx.lineTo(l.points[i].x, l.points[i].y);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.moveTo(l.x1, l.y1);
      ctx.lineTo(l.x2, l.y2);
      ctx.stroke();
    }
  }
}

function drawCurseHint() {
  if (!game.curseActive) return;
  const a = 0.72 + Math.sin(game.time * 11) * 0.2;
  const x = game.player.x;
  const y = game.player.y - 26;
  ctx.font = "bold 14px monospace";
  ctx.textAlign = "center";
  const txt = "衰老";
  const tw = ctx.measureText(txt).width + 12;
  ctx.fillStyle = `rgba(25,10,10,${a * 0.9})`;
  ctx.fillRect(x - tw / 2, y - 14, tw, 18);
  ctx.fillStyle = `rgba(255,170,170,${a})`;
  ctx.fillText(txt, x, y);
}

function updateHUD() {
  hudHp.textContent = `生命：${Math.ceil(game.player.hp)}`;
  hudTime.textContent = `時間：${game.time.toFixed(1)}s`;
  hudCombo.textContent = `連殺：${game.combo}`;
  hudSpr.textContent = `散射：Lv${game.upgrades.spread}`;
  hudBnc.textContent = `彈射：Lv${game.upgrades.bounce}`;
  hudDmg.textContent = `重擊：Lv${game.upgrades.damage}`;
}

function update(dt) {
  if (game.over || game.paused) return;

  game.time += dt;
  if (game.time >= 240 && !game.finalBossSpawned && !game.finalBossIntroOpen) {
    showFinalBossIntro();
    return;
  }
  updateBackground(dt);

  if (game.comboTimer > 0) {
    game.comboTimer -= dt;
    if (game.comboTimer <= 0) {
      game.combo = 0;
      game.frenzy.milestone = 0;
    }
  }

  const p = spawnPattern(game.time);
  game.spawnTimer -= dt;
  game.bossTimer -= dt;

  if (game.spawnTimer <= 0) {
    game.spawnTimer = p.interval;
    if (game.enemies.filter(e => e.alive).length < p.maxAlive) {
      for (let i = 0; i < p.count; i++) spawnEnemy();
    }
  }

  if (game.bossTimer <= 0 && !game.finalBossSpawned && game.time < 240) {
    game.bossTimer = bossSpawnIntervalByTime(game.time);
    spawnBoss();
  }

  game.player.update(dt);
  updatePlayerBullets(dt);
  updateEnemyBullets(dt);
  updateEnemies(dt);
  updatePowerups(dt);
  updateMedkits(dt);
  updateEffects(dt);
}

function draw() {
  drawBackground();
  drawBullets();
  for (const e of game.enemies) e.draw();
  drawPowerups();
  drawMedkits();
  drawEffects();
  game.player.draw();
  drawCurseHint();
  updateHUD();
}

function refreshJoysticks() {
  const rm = joyMove.getBoundingClientRect();
  const ra = joyAim.getBoundingClientRect();
  moveCenter.x = rm.left + rm.width / 2;
  moveCenter.y = rm.top + rm.height / 2;
  moveRadius = rm.width * 0.36;
  aimCenter.x = ra.left + ra.width / 2;
  aimCenter.y = ra.top + ra.height / 2;
  aimRadius = ra.width * 0.36;
}

function applyStick(t, c, r, out, el) {
  const dx = t.clientX - c.x;
  const dy = t.clientY - c.y;
  const len = Math.hypot(dx, dy) || 1;
  const m = Math.min(len, r);
  const nx = dx / len;
  const ny = dy / len;
  out.x = nx * (m / r);
  out.y = ny * (m / r);
  el.style.transform = `translate(${nx * m}px,${ny * m}px)`;
}

function resetGame() {
  game.guaranteedPowerups = [false, false, false];
  game.player = new Player();
  game.enemies = [];
  game.playerBullets = [];
  game.enemyBullets = [];
  game.powerups = [];
  game.medkits = [];
  game.effects = { rings: [], lines: [], snow: [] };
  game.score = 0;
  game.time = 0;
  game.combo = 0;
  game.comboTimer = 0;
  game.spawnTimer = 0;
  game.bossTimer = bossSpawnIntervalByTime(0);
  game.bossCount = 0;
  game.over = false;
  game.paused = false;
  game.pendingPowerup = 0;
  game.firstPowerupGiven = false;
  game.firstMedkitGiven = false;
  game.curseActive = false;
  game.medkitTimer = rand(15, 40);
  game.finalBossIntroOpen = false;
  game.finalBossSpawned = false;
  game.finalBossDefeated = false;
  game.inFinalBattle = false;
  game.element = null;
  game.upgrades = { elementLv: 0, spread: 0, bounce: 0, damage: 0 };
  game.frenzy = { time: 0, rateMul: 1.4, dmgMul: 1.25, milestone: 0 };

  inputMove.x = inputMove.y = inputAim.x = inputAim.y = 0;
  stickMove.style.transform = "translate(0,0)";
  stickAim.style.transform = "translate(0,0)";
  elementModal.style.display = "none";
  upgradeModal.style.display = "none";
  gameOverTitle.textContent = "GAME OVER";
  gameOverModal.style.display = "none";
  finalBossModal.style.display = "none";
}

function onResize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  initBackground();
  refreshJoysticks();
}

window.addEventListener("resize", onResize);
onResize();

document.addEventListener("touchstart", e => e.preventDefault(), { passive: false });
document.addEventListener("touchmove", e => e.preventDefault(), { passive: false });

joyMove.addEventListener("touchstart", e => {
  if (moveTouchId !== null) return;
  const t = e.changedTouches[0];
  moveTouchId = t.identifier;
  applyStick(t, moveCenter, moveRadius, inputMove, stickMove);
}, { passive: false });

joyAim.addEventListener("touchstart", e => {
  if (aimTouchId !== null) return;
  const t = e.changedTouches[0];
  aimTouchId = t.identifier;
  applyStick(t, aimCenter, aimRadius, inputAim, stickAim);
}, { passive: false });

document.addEventListener("touchmove", e => {
  for (const t of e.changedTouches) {
    if (t.identifier === moveTouchId) applyStick(t, moveCenter, moveRadius, inputMove, stickMove);
    if (t.identifier === aimTouchId) applyStick(t, aimCenter, aimRadius, inputAim, stickAim);
  }
}, { passive: false });

function clearTouch(e) {
  for (const t of e.changedTouches) {
    if (t.identifier === moveTouchId) {
      moveTouchId = null;
      inputMove.x = 0;
      inputMove.y = 0;
      stickMove.style.transform = "translate(0,0)";
    }
    if (t.identifier === aimTouchId) {
      aimTouchId = null;
      inputAim.x = 0;
      inputAim.y = 0;
      stickAim.style.transform = "translate(0,0)";
    }
  }
}
document.addEventListener("touchend", clearTouch, { passive: false });
document.addEventListener("touchcancel", clearTouch, { passive: false });

pickFire.addEventListener("touchstart", () => chooseElement("fire"), { passive: false });
pickIce.addEventListener("touchstart", () => chooseElement("ice"), { passive: false });
pickThunder.addEventListener("touchstart", () => chooseElement("thunder"), { passive: false });
pickFire.addEventListener("click", () => chooseElement("fire"));
pickIce.addEventListener("click", () => chooseElement("ice"));
pickThunder.addEventListener("click", () => chooseElement("thunder"));

upElement.addEventListener("touchstart", () => chooseUpgrade("element"), { passive: false });
upSpread.addEventListener("touchstart", () => chooseUpgrade("spread"), { passive: false });
upBounce.addEventListener("touchstart", () => chooseUpgrade("bounce"), { passive: false });
upDamage.addEventListener("touchstart", () => chooseUpgrade("damage"), { passive: false });

upElement.addEventListener("click", () => chooseUpgrade("element"));
upSpread.addEventListener("click", () => chooseUpgrade("spread"));
upBounce.addEventListener("click", () => chooseUpgrade("bounce"));
upDamage.addEventListener("click", () => chooseUpgrade("damage"));

restartBtn.addEventListener("touchstart", resetGame, { passive: false });
restartBtn.addEventListener("click", resetGame);
finalBossConfirm.addEventListener("touchstart", () => {
  finalBossModal.style.display = "none";
  game.finalBossIntroOpen = false;
  spawnFinalBoss();
  game.paused = false;
}, { passive: false });
finalBossConfirm.addEventListener("click", () => {
  finalBossModal.style.display = "none";
  game.finalBossIntroOpen = false;
  spawnFinalBoss();
  game.paused = false;
});

function loop(ts) {
  const dt = Math.min(0.033, ((ts - lastTs) / 1000) || 0.016);
  lastTs = ts;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

resetGame();
requestAnimationFrame(loop);
</script>
</body>
</html>

