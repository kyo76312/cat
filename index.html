<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>直向生存彈幕</title>
  <style>
    :root {
      --bg1: #0b1018;
      --bg2: #111c2f;
      --panel: rgba(0, 0, 0, 0.45);
      --text: #ecf3ff;
      --joy-size: 128px;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
      background: #0a0f18;
      color: var(--text);
      font-family: "Courier New", monospace;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background: linear-gradient(var(--bg1), var(--bg2));
    }

    #hud {
      position: fixed;
      left: 10px;
      top: 10px;
      z-index: 10;
      background: var(--panel);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.35;
      min-width: 172px;
    }

    #controls {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 20;
    }

    #joystick {
      position: absolute;
      left: 14px;
      bottom: 14px;
      width: var(--joy-size);
      height: var(--joy-size);
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.08);
      pointer-events: auto;
      touch-action: none;
    }

    #stick {
      position: absolute;
      width: 50px;
      height: 50px;
      left: calc(50% - 25px);
      top: calc(50% - 25px);
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.35);
      background: rgba(255,255,255,0.24);
      transform: translate(0, 0);
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.62);
      z-index: 30;
      touch-action: none;
    }

    .panel {
      width: min(360px, 90vw);
      background: #171f2f;
      border: 2px solid #2c3950;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
    }

    .panel h2 {
      margin: 0 0 10px;
      font-size: 24px;
    }

    .small {
      font-size: 13px;
      opacity: 0.9;
      margin-bottom: 10px;
    }

    .btn {
      width: 100%;
      border: 0;
      border-radius: 8px;
      padding: 10px;
      margin-top: 8px;
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      touch-action: none;
      background: #2ea86f;
    }

    .upgrade-btn {
      background: #2b3957;
      border: 1px solid #3d517a;
      text-align: left;
      padding: 10px;
      border-radius: 8px;
      margin-top: 8px;
      color: #fff;
      font-size: 14px;
      width: 100%;
      touch-action: none;
    }

    .tag {
      display: inline-block;
      border: 1px solid #4a5f87;
      border-radius: 999px;
      font-size: 12px;
      padding: 2px 8px;
      margin: 2px;
      background: rgba(123, 164, 240, 0.2);
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="hud">
    <div id="hudHp">生命：100</div>
    <div id="hudScore">分數：0</div>
    <div id="hudTime">時間：0.0s</div>
    <div id="hudCombo">連殺：0</div>
    <div id="hudMulti">倍率：x1.00</div>
    <div style="margin-top:6px;">技能：</div>
    <div id="hudSkillPen">穿透：Lv0</div>
    <div id="hudSkillSpr">散射：Lv0</div>
    <div id="hudSkillBnc">彈射：Lv0</div>
    <div id="hudSkillExp">爆炸：Lv0</div>
  </div>

  <div id="controls">
    <div id="joystick"><div id="stick"></div></div>
  </div>

  <div id="upgradeModal" class="overlay">
    <div class="panel">
      <h2>選擇升級</h2>
      <div class="small">吃到 POWERUP，四選一</div>
      <button class="upgrade-btn" data-type="pierce" id="upPierce"></button>
      <button class="upgrade-btn" data-type="spread" id="upSpread"></button>
      <button class="upgrade-btn" data-type="bounce" id="upBounce"></button>
      <button class="upgrade-btn" data-type="explode" id="upExplode"></button>
      <div id="queueInfo" class="small" style="margin-top:10px;"></div>
    </div>
  </div>

  <div id="gameOverModal" class="overlay">
    <div class="panel">
      <h2 style="color:#ff7f7f;">GAME OVER</h2>
      <div id="resultText" class="small"></div>
      <button id="restartBtn" class="btn">重新開始</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = false;

    const hudHp = document.getElementById("hudHp");
    const hudScore = document.getElementById("hudScore");
    const hudTime = document.getElementById("hudTime");
    const hudCombo = document.getElementById("hudCombo");
    const hudMulti = document.getElementById("hudMulti");
    const hudSkillPen = document.getElementById("hudSkillPen");
    const hudSkillSpr = document.getElementById("hudSkillSpr");
    const hudSkillBnc = document.getElementById("hudSkillBnc");
    const hudSkillExp = document.getElementById("hudSkillExp");

    const upgradeModal = document.getElementById("upgradeModal");
    const upPierce = document.getElementById("upPierce");
    const upSpread = document.getElementById("upSpread");
    const upBounce = document.getElementById("upBounce");
    const upExplode = document.getElementById("upExplode");
    const queueInfo = document.getElementById("queueInfo");

    const gameOverModal = document.getElementById("gameOverModal");
    const restartBtn = document.getElementById("restartBtn");
    const resultText = document.getElementById("resultText");

    const joystick = document.getElementById("joystick");
    const stick = document.getElementById("stick");

    const heroImg = new Image();
    const slimeImg = new Image();
    const bulletImg = new Image();
    heroImg.src = "assets/hero.png";
    slimeImg.src = "assets/slime.png";
    bulletImg.src = "assets/bullet.png";

    const W = () => canvas.width;
    const H = () => canvas.height;
    const rand = (a, b) => Math.random() * (b - a) + a;
    const randi = (a, b) => Math.floor(rand(a, b + 1));
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function circleHit(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const rr = a.r + b.r;
      return dx * dx + dy * dy <= rr * rr;
    }

    class Player {
      constructor() {
        this.x = W() * 0.5;
        this.y = H() * 0.82;
        this.r = 12;
        this.maxHp = 100;
        this.hp = 100;
        this.speed = 265;
        this.fireCd = 0;
        this.fireInterval = 0.1; // 自動連發
      }

      update(dt) {
        this.x += input.x * this.speed * dt;
        this.y += input.y * this.speed * dt;

        // 修正：玩家永遠不會移出畫面
        this.x = clamp(this.x, this.r, W() - this.r);
        this.y = clamp(this.y, this.r, H() - this.r);

        this.fireCd -= dt;
        if (this.fireCd <= 0 && !game.over && !game.upgradeOpen) {
          this.fireCd = this.fireInterval;
          spawnPlayerBullets();
        }
      }

      draw() {
        const s = 28;
        if (heroImg.complete && heroImg.naturalWidth) {
          ctx.drawImage(heroImg, this.x - s / 2, this.y - s / 2, s, s);
        } else {
          ctx.fillStyle = "#67d7ff";
          ctx.fillRect(this.x - 10, this.y - 10, 20, 20);
        }
      }

      hurt(dmg) {
        this.hp -= dmg;
        if (this.hp < 0) this.hp = 0;
        resetCombo();
        if (this.hp <= 0) {
          game.over = true;
          openGameOver();
        }
      }
    }

    let enemyIdSeq = 1;
    class Enemy {
      constructor({ isBoss = false, bossIndex = 0, x = rand(20, W() - 20), y = -30, hpScale = 1 }) {
        this.id = enemyIdSeq++;
        this.isBoss = isBoss;
        this.bossIndex = bossIndex;
        this.x = x;
        this.y = y;
        this.alive = true;

        if (isBoss) {
          const growth = 1 + bossIndex * 0.18;
          this.r = 18 * growth;
          this.maxHp = Math.floor((55 + bossIndex * 24) * hpScale);
          this.hp = this.maxHp;
          this.speed = 130 + bossIndex * 8;
          this.affixes = new Set(pickBossAffixes(game.time));
          this.dashCd = rand(2.2, 3.4);
          this.dashTime = 0;
          this.dashVx = 0;
          this.dashVy = 0;
          this.shieldCd = rand(4.5, 6.5);
          this.shieldTime = 0;
          this.summonCd = rand(4, 6);
        } else {
          this.r = 11;
          this.maxHp = Math.max(1, Math.floor((1 + game.time / 20) * hpScale));
          this.hp = this.maxHp;
          this.speed = 95 + game.time * 0.9 + rand(0, 45);
          this.affixes = new Set();
        }
      }

      get shieldActive() {
        return this.isBoss && this.affixes.has("shield") && this.shieldTime > 0;
      }

      takeDamage(dmg) {
        if (!this.alive) return;
        let final = dmg;
        if (this.shieldActive) final *= 0.25; // 護盾減傷
        this.hp -= final;
      }

      update(dt) {
        if (!this.alive) return;

        if (this.isBoss) {
          if (this.affixes.has("shield")) {
            this.shieldCd -= dt;
            if (this.shieldCd <= 0) {
              this.shieldCd = rand(5, 7);
              this.shieldTime = 1.25;
            }
            this.shieldTime = Math.max(0, this.shieldTime - dt);
          }

          if (this.affixes.has("dash")) {
            if (this.dashTime > 0) {
              this.dashTime -= dt;
              this.x += this.dashVx * dt;
              this.y += this.dashVy * dt;
              return;
            } else {
              this.dashCd -= dt;
              if (this.dashCd <= 0) {
                this.dashCd = rand(2.6, 3.8);
                this.dashTime = 0.35;
                const dx = game.player.x - this.x;
                const dy = game.player.y - this.y;
                const d = Math.hypot(dx, dy) || 1;
                const dashSpeed = this.speed * 2.2;
                this.dashVx = dx / d * dashSpeed;
                this.dashVy = dy / d * dashSpeed;
              }
            }
          }

          if (this.affixes.has("summon")) {
            this.summonCd -= dt;
            if (this.summonCd <= 0) {
              this.summonCd = rand(4.2, 6.2);
              for (let i = 0; i < 2; i++) {
                game.enemies.push(new Enemy({
                  isBoss: false,
                  x: this.x + rand(-32, 32),
                  y: this.y + rand(-10, 10),
                  hpScale: 1 + game.time / 140
                }));
              }
            }
          }
        }

        const dx = game.player.x - this.x;
        const home = clamp(dx / 150, -1, 1);
        this.x += home * (70 + game.time * 0.2 + (this.isBoss ? 20 : 0)) * dt;
        this.y += this.speed * dt;
      }

      draw() {
        if (!this.alive) return;

        const s = this.r * 2.1;
        if (slimeImg.complete && slimeImg.naturalWidth) {
          ctx.drawImage(slimeImg, this.x - s / 2, this.y - s / 2, s, s);
        } else {
          ctx.fillStyle = this.isBoss ? "#ff9a9a" : "#82ff8f";
          ctx.fillRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
        }

        if (this.isBoss) {
          // Boss 血條
          ctx.fillStyle = "#000";
          ctx.fillRect(this.x - 36, this.y - this.r - 12, 72, 5);
          const ratio = Math.max(0, this.hp / this.maxHp);
          ctx.fillStyle = this.shieldActive ? "#8ac4ff" : "#ff5a5a";
          ctx.fillRect(this.x - 36, this.y - this.r - 12, 72 * ratio, 5);

          // 詞綴文字
          const names = [...this.affixes].map(affixNameZh).join(" ");
          ctx.font = "bold 11px monospace";
          ctx.textAlign = "center";
          ctx.fillStyle = "#ffe082";
          ctx.fillText(names, this.x, this.y - this.r - 18);
        }
      }
    }

    const game = {
      player: null,
      bullets: [],
      enemies: [],
      powerups: [],
      pendingUpgrade: 0,
      upgrades: { pierce: 0, spread: 0, bounce: 0, explode: 0 },
      score: 0,
      time: 0,
      spawnTimer: 0,
      bossTimer: 10,
      bossCount: 0,
      combo: 0,
      comboTimer: 0,
      over: false,
      upgradeOpen: false
    };

    const input = { x: 0, y: 0 };
    let joyTouchId = null;
    let joyCenter = { x: 0, y: 0 };
    let joyRadius = 0;
    let lastTs = 0;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      refreshJoystick();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // 防止行動裝置滾動
    document.addEventListener("touchstart", e => e.preventDefault(), { passive: false });
    document.addEventListener("touchmove", e => e.preventDefault(), { passive: false });

    function affixNameZh(key) {
      if (key === "split") return "分裂";
      if (key === "dash") return "衝刺";
      if (key === "shield") return "護盾";
      if (key === "summon") return "召喚";
      return key;
    }

    function pickBossAffixes(t) {
      const pool = ["split", "dash", "shield", "summon"];
      const count = clamp(1 + Math.floor(t / 30), 1, 4);
      const picked = [];
      while (picked.length < count) {
        const a = pool[randi(0, pool.length - 1)];
        if (!picked.includes(a)) picked.push(a);
      }
      return picked;
    }

    function spawnPlayerBullets() {
      const spreadLv = game.upgrades.spread;
      const rows = 1 + spreadLv; // 散射 Lv1 => 多一排
      const gap = 13;
      const center = (rows - 1) / 2;
      const speed = 700;
      for (let i = 0; i < rows; i++) {
        const offsetX = (i - center) * gap;
        const angle = (i - center) * 0.05; // 微角度
        const vx = Math.sin(angle) * speed;
        const vy = -Math.cos(angle) * speed;
        game.bullets.push({
          x: game.player.x + offsetX,
          y: game.player.y - 14,
          vx, vy, r: 5,
          baseDamage: 1,
          pierceLeft: game.upgrades.pierce, // 可額外穿過幾隻
          bounceLeft: game.upgrades.bounce,
          alive: true
        });
      }
    }

    function spawnEnemies(dt) {
      game.spawnTimer -= dt;
      game.bossTimer -= dt;

      const diff = Math.min(2.2, game.time / 60);
      const interval = Math.max(0.08, 0.5 - diff * 0.23);
      const batch = 2 + Math.floor(game.time / 12); // 難度大幅增加

      if (game.spawnTimer <= 0) {
        game.spawnTimer = interval;
        for (let i = 0; i < batch; i++) {
          game.enemies.push(new Enemy({
            isBoss: false,
            hpScale: 1 + game.time / 80
          }));
        }
      }

      if (game.bossTimer <= 0) {
        game.bossTimer = 10;
        game.bossCount += 1;
        game.enemies.push(new Enemy({
          isBoss: true,
          bossIndex: game.bossCount,
          hpScale: 1 + game.time / 90
        }));
      }
    }

    function createPowerup(x, y) {
      game.powerups.push({
        x, y, r: 18, ttl: 14,
        text: "POWERUP"
      });
    }

    function onEnemyKilled(enemy, fromPlayerBullet = true) {
      if (!enemy.alive) return;
      enemy.alive = false;

      if (enemy.isBoss) {
        createPowerup(enemy.x, enemy.y);

        if (enemy.affixes.has("split")) {
          const n = 2 + Math.min(3, Math.floor(game.time / 50));
          for (let i = 0; i < n; i++) {
            const child = new Enemy({
              isBoss: false,
              x: enemy.x + rand(-26, 26),
              y: enemy.y + rand(-8, 8),
              hpScale: 1.2 + game.time / 180
            });
            child.r = Math.max(8, enemy.r * 0.48);
            child.maxHp = Math.max(2, Math.floor(enemy.maxHp * 0.14));
            child.hp = child.maxHp;
            child.speed = enemy.speed * 1.15;
            game.enemies.push(child);
          }
        }
      }

      if (fromPlayerBullet) addScore(enemy.isBoss ? 35 : 4);
    }

    function addScore(base) {
      if (game.comboTimer > 0) game.combo += 1;
      else game.combo = 1;
      game.comboTimer = 2.0;

      const comboMulti = 1 + Math.min(3, game.combo * 0.08);
      const hpRatio = game.player.hp / game.player.maxHp;
      const dangerMulti = 1 + (1 - hpRatio) * 0.6; // 危險倍率
      const gain = Math.round(base * comboMulti * dangerMulti);
      game.score += gain;
    }

    function resetCombo() {
      game.combo = 0;
      game.comboTimer = 0;
    }

    function closestEnemyFrom(x, y, exceptId, range) {
      let best = null;
      let bestD = range;
      for (const e of game.enemies) {
        if (!e.alive || e.id === exceptId) continue;
        const d = Math.hypot(e.x - x, e.y - y);
        if (d < bestD) {
          best = e;
          bestD = d;
        }
      }
      return best;
    }

    function explosionDamage(x, y, level, excludeEnemy) {
      if (level <= 0) return;
      const radius = 26 + level * 10;
      for (const e of game.enemies) {
        if (!e.alive || e === excludeEnemy) continue;
        const d = Math.hypot(e.x - x, e.y - y);
        if (d <= radius + e.r) {
          e.takeDamage(1 + level * 0.45);
          if (e.hp <= 0) onEnemyKilled(e, true);
        }
      }

      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255,180,100,0.7)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function updateBullets(dt) {
      for (const b of game.bullets) {
        if (!b.alive) continue;
        b.x += b.vx * dt;
        b.y += b.vy * dt;

        if (b.y < -30 || b.y > H() + 30 || b.x < -30 || b.x > W() + 30) {
          b.alive = false;
          continue;
        }

        for (const e of game.enemies) {
          if (!e.alive) continue;
          if (!circleHit(b, e)) continue;

          e.takeDamage(b.baseDamage);
          if (game.upgrades.explode > 0) {
            explosionDamage(e.x, e.y, game.upgrades.explode, e);
          }
          if (e.hp <= 0) onEnemyKilled(e, true);

          let bounced = false;
          if (b.bounceLeft > 0) {
            const next = closestEnemyFrom(e.x, e.y, e.id, 200);
            if (next) {
              const dx = next.x - e.x;
              const dy = next.y - e.y;
              const d = Math.hypot(dx, dy) || 1;
              const speed = 700;
              b.vx = dx / d * speed;
              b.vy = dy / d * speed;
              b.x = e.x;
              b.y = e.y;
              b.bounceLeft -= 1;
              bounced = true;
            }
          }

          if (!bounced) {
            if (b.pierceLeft > 0) {
              b.pierceLeft -= 1;
              b.y -= 4;
            } else {
              b.alive = false;
            }
          }
          break;
        }
      }
      game.bullets = game.bullets.filter(b => b.alive);
    }

    function updatePowerups(dt) {
      for (const p of game.powerups) {
        p.ttl -= dt;
        p.y += 10 * dt;
        if (circleHit(p, game.player)) {
          p.ttl = -1;
          game.pendingUpgrade += 1;
          openUpgradeIfNeeded();
        }
      }
      game.powerups = game.powerups.filter(p => p.ttl > 0);
    }

    function openUpgradeIfNeeded() {
      if (game.pendingUpgrade <= 0 || game.upgradeOpen || game.over) return;
      game.upgradeOpen = true;
      upgradeModal.style.display = "flex";
      refreshUpgradeButtons();
    }

    function refreshUpgradeButtons() {
      const u = game.upgrades;
      upPierce.textContent = `穿透 Lv${u.pierce}：再多穿 ${u.pierce + 1} 隻`;
      upSpread.textContent = `散射 Lv${u.spread}：再增加 1 排子彈`;
      upBounce.textContent = `彈射 Lv${u.bounce}：命中後可再彈 1 次`;
      upExplode.textContent = `爆炸 Lv${u.explode}：擴大範圍傷害`;
      queueInfo.textContent = `待選升級：${game.pendingUpgrade}`;
    }

    function chooseUpgrade(type) {
      game.upgrades[type] += 1;
      game.pendingUpgrade -= 1;
      if (game.pendingUpgrade > 0) {
        refreshUpgradeButtons();
      } else {
        game.upgradeOpen = false;
        upgradeModal.style.display = "none";
      }
    }

    upPierce.addEventListener("touchstart", () => chooseUpgrade("pierce"), { passive: false });
    upSpread.addEventListener("touchstart", () => chooseUpgrade("spread"), { passive: false });
    upBounce.addEventListener("touchstart", () => chooseUpgrade("bounce"), { passive: false });
    upExplode.addEventListener("touchstart", () => chooseUpgrade("explode"), { passive: false });

    upPierce.addEventListener("click", () => chooseUpgrade("pierce"));
    upSpread.addEventListener("click", () => chooseUpgrade("spread"));
    upBounce.addEventListener("click", () => chooseUpgrade("bounce"));
    upExplode.addEventListener("click", () => chooseUpgrade("explode"));

    function updateEnemies(dt) {
      for (const e of game.enemies) {
        if (!e.alive) continue;
        e.update(dt);

        if (e.y > H() + e.r + 20) {
          e.alive = false;
          game.player.hurt(e.isBoss ? 18 : 4);
          continue;
        }

        if (circleHit(e, game.player)) {
          e.alive = false;
          game.player.hurt(e.isBoss ? 20 : 10);
        }
      }
      game.enemies = game.enemies.filter(e => e.alive);
    }

    function updateHUD() {
      const comboMulti = 1 + Math.min(3, game.combo * 0.08);
      const dangerMulti = 1 + (1 - game.player.hp / game.player.maxHp) * 0.6;
      const totalMulti = comboMulti * dangerMulti;

      hudHp.textContent = `生命：${Math.ceil(game.player.hp)}`;
      hudScore.textContent = `分數：${game.score}`;
      hudTime.textContent = `時間：${game.time.toFixed(1)}s`;
      hudCombo.textContent = `連殺：${game.combo}`;
      hudMulti.textContent = `倍率：x${totalMulti.toFixed(2)}`;
      hudSkillPen.textContent = `穿透：Lv${game.upgrades.pierce}`;
      hudSkillSpr.textContent = `散射：Lv${game.upgrades.spread}`;
      hudSkillBnc.textContent = `彈射：Lv${game.upgrades.bounce}`;
      hudSkillExp.textContent = `爆炸：Lv${game.upgrades.explode}`;
    }

    function drawBackground() {
      ctx.fillStyle = "#0c1220";
      ctx.fillRect(0, 0, W(), H());
      ctx.fillStyle = "rgba(255,255,255,0.16)";
      for (let i = 0; i < 70; i++) {
        const y = (i * 35 + (game.time * 180) % H()) % H();
        const x = (i * 67) % W();
        ctx.fillRect(x, y, 2, 2);
      }
    }

    function drawPowerups() {
      for (const p of game.powerups) {
        ctx.fillStyle = "#ffd95a";
        ctx.font = "bold 16px monospace";
        ctx.textAlign = "center";
        ctx.fillText(p.text, p.x, p.y);
      }
    }

    function drawBullets() {
      for (const b of game.bullets) {
        const s = 12;
        if (bulletImg.complete && bulletImg.naturalWidth) {
          ctx.drawImage(bulletImg, b.x - s / 2, b.y - s / 2, s, s);
        } else {
          ctx.fillStyle = "#ffe57d";
          ctx.fillRect(b.x - 2, b.y - 6, 4, 12);
        }
      }
    }

    function draw() {
      drawBackground();
      drawBullets();
      for (const e of game.enemies) e.draw();
      drawPowerups();
      game.player.draw();
      updateHUD();
    }

    function openGameOver() {
      resultText.textContent = `生存 ${game.time.toFixed(1)} 秒，擊殺分數 ${game.score}`;
      gameOverModal.style.display = "flex";
    }

    function resetGame() {
      game.player = new Player();
      game.bullets = [];
      game.enemies = [];
      game.powerups = [];
      game.pendingUpgrade = 0;
      game.upgrades = { pierce: 0, spread: 0, bounce: 0, explode: 0 };
      game.score = 0;
      game.time = 0;
      game.spawnTimer = 0;
      game.bossTimer = 10;
      game.bossCount = 0;
      game.combo = 0;
      game.comboTimer = 0;
      game.over = false;
      game.upgradeOpen = false;

      input.x = 0;
      input.y = 0;
      stick.style.transform = "translate(0,0)";
      gameOverModal.style.display = "none";
      upgradeModal.style.display = "none";
    }

    restartBtn.addEventListener("touchstart", resetGame, { passive: false });
    restartBtn.addEventListener("click", resetGame);

    function refreshJoystick() {
      const r = joystick.getBoundingClientRect();
      joyCenter.x = r.left + r.width / 2;
      joyCenter.y = r.top + r.height / 2;
      joyRadius = r.width * 0.36;
    }
    refreshJoystick();
    window.addEventListener("resize", refreshJoystick);

    function moveStickByTouch(t) {
      const dx = t.clientX - joyCenter.x;
      const dy = t.clientY - joyCenter.y;
      const len = Math.hypot(dx, dy) || 1;
      const c = Math.min(len, joyRadius);
      const nx = dx / len;
      const ny = dy / len;
      input.x = nx * (c / joyRadius);
      input.y = ny * (c / joyRadius);
      stick.style.transform = `translate(${nx * c}px, ${ny * c}px)`;
    }

    joystick.addEventListener("touchstart", (e) => {
      if (joyTouchId !== null || game.over) return;
      const t = e.changedTouches[0];
      joyTouchId = t.identifier;
      moveStickByTouch(t);
    }, { passive: false });

    document.addEventListener("touchmove", (e) => {
      if (joyTouchId === null) return;
      for (const t of e.changedTouches) {
        if (t.identifier === joyTouchId) {
          moveStickByTouch(t);
          break;
        }
      }
    }, { passive: false });

    function endJoyTouch(e) {
      if (joyTouchId === null) return;
      for (const t of e.changedTouches) {
        if (t.identifier === joyTouchId) {
          joyTouchId = null;
          input.x = 0;
          input.y = 0;
          stick.style.transform = "translate(0,0)";
          break;
        }
      }
    }
    document.addEventListener("touchend", endJoyTouch, { passive: false });
    document.addEventListener("touchcancel", endJoyTouch, { passive: false });

    function update(dt) {
      if (game.over) return;
      if (game.upgradeOpen) return; // 升級時暫停遊戲

      game.time += dt;
      if (game.comboTimer > 0) {
        game.comboTimer -= dt;
        if (game.comboTimer <= 0) game.combo = 0;
      }

      game.player.update(dt);
      spawnEnemies(dt);
      updateBullets(dt);
      updateEnemies(dt);
      updatePowerups(dt);
    }

    function loop(ts) {
      const dt = Math.min(0.033, ((ts - lastTs) / 1000) || 0.016);
      lastTs = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
